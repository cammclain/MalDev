Developing a Long-Term Zig-Based Adversary Implant (Lightweight & Stealthy Havoc-Inspired)
1. Advantages and Considerations of Zig for an Adversary Implant
Why Zig? Zig is emerging as a powerful systems language that combines the low-level control of C with some safety features reminiscent of Rust. This makes it appealing for offensive implant development. Key advantages include:
Minimal Runtime & Binary Size: Zig produces static binaries with no bulky runtime or garbage collector, resulting in very small payloads (often on par with C). A “Hello World” in Zig is about the same size as in C, whereas other languages often yield much larger binaries. This minimal footprint is ideal for stealth, as smaller binaries leave a smaller memory and disk presence. Zig’s standard library is lean and you can strip debug info easily, further reducing size.
Performance and Low-Level Control: Zig is designed for performance akin to C. There’s no hidden memory management or heavyweight runtime calls – you manage memory manually, which means you can write highly optimized, deterministic code. Unlike Go or higher-level languages, Zig exposes the “underlying plumbing” so you can control allocations and memory layout with precision. In optimized builds, safety checks can be removed, yielding performance similar to C. You can even include inline assembly or drop down to raw syscalls when needed.
Cross-Compilation Made Easy: One of Zig’s standout features is its cross-compilation support. The Zig compiler can target multiple OS/architectures out-of-the-box, even acting as a cross-toolchain for C/C++ code. For a red team, this means you can build Windows implants from a Linux or macOS build environment with a single command (e.g. zig build-exe -target x86_64-windows​
GITHUB.COM
), without wrestling with separate cross-compilers or SDKs. This flexibility speeds up multi-platform payload development.
Memory Safety Improvements Over C: While Zig is not fully memory-safe like Rust, it does incorporate several safety mechanisms by default that C lacks. For example, Zig uses optional types to avoid null-pointer dereferences (you must explicitly handle the null case), performs bounds-checking on array accesses (in debug builds), checks for integer overflow, and uses a distinct type for C-style strings vs. slice lengths. These runtime checks (which can be disabled in release builds) help catch common bugs like buffer overflows or use-after-frees during development. Zig also provides a variety of allocator options (general, arena, etc.) that can catch double frees and other allocation errors when used in debug mode. This makes Zig less error-prone than raw C, without the steep learning curve of Rust’s borrow checker.
Easy C Integration: Zig can directly call C functions and use C headers without an FFI gymnastics. You can import a C header and Zig will translate it on the fly. This is useful for offensive development because you can leverage Windows API calls or existing C offensive libraries easily. For example, calling Win32 APIs (like MessageBoxA or VirtualAlloc) can be done by simply declaring the extern functions and calling them, rather than writing complex bindings. This also means you can reuse portions of C-based implants or shellcode within Zig seamlessly. The Zig toolchain can even compile C/C++ code as part of your build (via zig cc), so adopting Zig doesn’t mean abandoning all your existing C code.
Modern Syntax and Comptime: Zig’s syntax and semantics are more modern and concise than C. It has a Rust-like feel (e.g. const variables, if expressions) but without Rust’s heavy generics/traits system. This can result in faster development and easier-to-read code for implants. A particularly powerful Zig feature is comptime – the ability to execute code at compile-time. This lets you do things like computing constants, encoding data, or even generating code during compilation. In an implant context, comptime can be used to embed or obfuscate data. For instance, Zig Strike (a Zig-based evasion toolkit) used comptime to convert and store a wide-string shellcode blob in the PE data section, only constructing it at runtime when needed. Such tricks improve performance and stealth (no decoding loop at runtime) and make static analysis harder.
How Zig Compares to C and Rust: Zig sits in a middle ground between C and Rust:
Versus C: Zig provides many conveniences (like safer default behaviors, package manager, cross-compilation, and easier string/struct handling) while maintaining C-like performance and simplicity. Unlike C, Zig has no undefined behavior in its specification – many things that would silently misbehave in C (integer overflow, out-of-bounds access) will safely error or panic in Zig’s safe mode. This can prevent certain classes of vulnerabilities. Also, Zig’s build tooling is more user-friendly (no need for makefiles if you use build.zig, and dependency management is builtin). For a C developer, picking up Zig is straightforward; it feels like a more robust C. On the downside, Zig’s manual memory management means you still must be careful (use-after-free or leaks can occur if you’re not vigilant, just as in C). There’s no automatic memory safety as in Rust, so the onus is on the developer to write secure code (Zig just gives better tools to do so). Another consideration: the Zig compiler is still under active development (not 1.0 yet), so occasional breaking changes or less mature documentation can be an issue. In contrast, C is extremely stable and universally supported (but that stability comes with decades-old pitfalls Zig is trying to address).
Versus Rust: Rust offers stronger compile-time guarantees (borrow checking, strict aliasing rules) that virtually eliminate memory corruption bugs if you stay in safe Rust. Zig does not have a borrow checker or strict ownership model – it opts for simplicity and trusts the programmer more. This means writing a Zig implant will be closer to C style (careful manual memory handling) whereas Rust forces a different paradigm. The benefit is that Zig has a gentler learning curve: many developers report feeling productive in Zig in days, whereas Rust can take months to master. For a red-teamer who isn’t a full-time software engineer, Zig can be more approachable. Zig code is typically smaller and simpler than equivalent Rust code for low-level tasks, due to fewer language abstractions. Another practical difference is binary size: Rust tends to produce larger binaries because of static linking of its standard library and additional safety glue. Even a stripped “Hello World” in Rust can be tens of KB, whereas Zig’s can be just a few KB. There are techniques to minimize Rust binary size, but Zig hits minimal size out-of-the-box. On the other hand, Rust’s memory safety and thread-safety guarantees can be very valuable for a long-term implant that must run stably. A memory corruption crash in your implant could burn the operation. If you have the expertise, Rust is arguably “safer by default.” However, Rust’s complexity (and potential runtime overhead if you inadvertently include heavy libraries) might be overkill if your goal is a lean, custom tool. Zig gives you more direct control and is more malleable during development (no fighting the borrow checker for unconventional techniques). In summary: Zig trades some of Rust’s safety for C-like ergonomics and binary size – a trade-off that can make sense for offensive tools where stealth and size are paramount and the developer is careful.
Cross-Platform Needs: Both Rust and C can also target Windows x64 (Rust has cross or target triples, C has cross-compilers), but Zig makes it trivial without installing SDKs. If your implant might target Linux or macOS in the future, Zig can handle those too with one toolchain. Rust is also multi-platform but each target needs the Rust standard library compiled (or use #![no_std] which is advanced). Zig’s single compiler binary covers everything, which is very handy in practice. For example, Zig can produce position-independent code or even WebAssembly easily, which might open up interesting techniques (like a WASM payload executed in-process).
Potential Downsides and Trade-offs:While Zig is promising, there are some considerations:
Immature Ecosystem: Zig’s ecosystem is growing but still smaller than Rust’s or even Python’s. Offensive security tooling in Zig is very new – you won’t find as many ready-made libraries or community snippets compared to C or Rust. Documentation, while improving, can sometimes be sparse or require reading Zig’s source to fully grasp behaviors. This means developing a complex implant in Zig might involve writing more from scratch (or porting from C) because you can’t just pull in a mature crate like you could in Rust. The benefit is you have full control over what goes into your binary (no dependency bloat), but the cost is more development time.
Manual Memory Management: Zig deliberately avoids automated memory management; there’s no garbage collector (unlike Go or Nim) and no automatic reference counting by default. For developers not used to manual free() logic, this can lead to bugs. The OffensiveZig project noted that Zig’s manual memory handling “may not be particularly user-friendly” for those without professional dev experience. In a long-running implant, memory leaks or fragmentation could become an issue over time. Zig does offer patterns to mitigate this (arenas you free all at once, or using defer to ensure frees happen), but it requires discipline. In Rust, the compiler would catch many mistakes at compile time; in Zig, you must rely on careful testing (possibly enabling Zig’s debug mode which can catch some errors). Essentially, Zig doesn’t prevent mistakes; it just makes it easier to avoid them if you know how.
Lack of Borrow Checker (Safety vs. Flexibility): Because Zig doesn’t enforce strict ownership like Rust, you have more leeway – which is a double-edged sword. You can implement any low-level trick (like self-modifying code or custom allocators) without fighting the language, but you might also accidentally write unsafe code without realizing it. Zig does have an unsafe block concept (for operations that bypass safety checks), but far fewer things are considered unsafe compared to Rust. For a red team implant where you might intentionally do unsafe things (e.g., casting raw pointers, executing shellcode in memory), Zig lets you do it easily – just remember Rust’s safety net isn’t there. That said, Zig’s philosophy is “crash early” in debug mode, which can help you catch errors during development rather than having an implant subtly misbehave in the field.
Tooling and Windows Support: Zig’s compiler is modern and generally excellent, but using Zig for Windows programming is a newer frontier. Some Windows-specific functionality might not have high-level Zig library support, requiring more direct FFI usage. C and C++ have decades of Windows APIs and examples; Zig might need you to translate some patterns manually. However, the ability to include C headers can mitigate this (for example, you could include <windows.h> in Zig). Also, debugging Zig on Windows (if needed) might not be as straightforward as with MSVC for C. These are not show-stoppers, just things to be aware of due to Zig’s relative youth.
In summary, Zig offers small, fast, and portable implants – ideal for stealth and flexibility. It provides enough safety to catch dumb mistakes, but not so much that it hinders low-level operations. When comparing to writing an implant in pure C, Zig can reduce development time and bugs (with features like safe integers and built-in cross-compiling). Compared to Rust, Zig may result in a smaller, simpler agent at the cost of foregoing Rust’s stronger safety guarantees. The choice often comes down to the developer’s comfort and the project requirements. Many red teamers have gravitated to languages like Nim or Go for similar reasons (uncommon language, fewer detections); Zig is in that category but with even more emphasis on low-level control and minimal footprint. Given these advantages, Zig is well-suited for a long-term adversary simulation implant that must be stealthy and efficient, as long as one manages the associated trade-offs responsibly.
2. Embedding a Lightweight Scripting Engine (CyberLang vs. RustPython)
Embedding a scripting engine into your implant can greatly increase its flexibility. It allows the operator to send high-level scripts or commands to be executed in-memory by the implant, rather than needing a new binary for each behavior. The Havoc framework, for example, supports running .NET assemblies in-memory and Python-based extensions, which gives operators a lot of post-exploitation flexibility. For a custom Zig implant, we consider using Cyber (or “CyberLang”) – a new lightweight scripting language written in Zig – versus using a Python interpreter like RustPython.Pros of CyberLang (Cyber Scripting Language):
Designed for Embedding and Speed: Cyber is explicitly built to be embedded in applications and games​
STS10.GITHUB.IO
. It’s a lightweight, fast VM with an interpreter and optional JIT compiler, aimed at being a “delightful” scripting experience​
STS10.GITHUB.IO
. Because it’s written in Zig, it should integrate easily with a Zig implant (no complex FFI needed). Cyber’s goals include high performance and efficiency – benchmarks show it executes script code on par with LuaJIT in many cases. This means using Cyber for on-target scripting won’t slow your implant significantly and keeps resource usage low.
Memory Safe and Concurrent: Unlike embedding raw Python or Lua C interpreters, Cyber claims memory safety and even offers concurrency via fibers. Memory safety is a big plus – a buggy script or malicious script input is less likely to crash the whole implant. Cyber achieves this in part by being a managed VM (similar to Lua’s model) but implemented with Zig’s safety. It also supports running multiple fibers (lightweight threads) which could let the implant handle multiple script tasks simultaneously without complex thread management in the implant itself.
Small Footprint: Being a young project, Cyber’s footprint is relatively small. While exact numbers depend on which parts of the library you include, it is certainly leaner than a full Python interpreter. RustPython, by contrast, is essentially a reimplementation of CPython and brings along a large subset of Python’s semantics (and thus overhead). In one comparison, embedding RustPython’s interpreter ballooned a “hello world” binary from ~0.4 MB to ~15 MB. CyberLang’s VM is likely only a few hundred KB in size (comparable to Lua’s 200-300KB). For a stealth implant, every megabyte in memory counts, so using a purpose-built small language is advantageous.
No Dependencies / Easy Integration: Because CyberLang is Zig code, you could compile it directly into your implant binary, running scripts in-memory without touching disk. No installation of scripting engines on the target is needed – it’s self-contained. That means you avoid using mscoree.dll (for .NET) or the need to drop a Python executable. It leaves a smaller footprint for defenders to pick up. Cyber’s embeddability means your implant can provide a scripting REPL or execute script tasks on the fly with minimal fuss.
Stealth and Novelty: Using a novel language like Cyber might help evade detection. Security products have signatures for known interpreters (like if they see memory patterns of Python or LuaJIT engines). CyberLang is new and not likely recognized by EDRs. Also, because the scripting is in-memory, you avoid triggers like AMSI that hook into known script hosts (PowerShell, WScript, etc.). In fact, AMSI (Antimalware Scan Interface) is integrated into Windows to scan scripts executed via common engines (PowerShell, VBA, JavaScript via WScript). A custom Zig/Cyber interpreter would not automatically load AMSI, meaning your script content won’t be proactively scanned by Windows Defender. This is a big stealth win – essentially flying under the radar that usually catches PowerShell or Python usage.
Sufficient Features for Post-Exploitation: CyberLang supports dynamic typing with the option of static types, and typical language features (variables, loops, functions). It’s not as rich as full Python, but for post-exploitation tasks, you often only need logic and the ability to call implant functions or OS APIs. Cyber can interface with C easily (FFI), so one could expose certain host functions (like readFile, spawnProcess, etc.) to the Cyber script environment for the operator to use. This way, the operator can write small scripts to orchestrate complex actions on the host using the primitives you expose.
Cons and Considerations for CyberLang:
Maturity and Community: Cyber is very new (first commit in late 2022). Bugs or missing features are possible. The language might change, and there is very little community usage compared to something like Python or Lua. Relying on it in a long-term implant means you should test it thoroughly to ensure stability. Edge cases might not be well-documented. Essentially, you’d be an early adopter – which is both a risk and a potential advantage (security products won’t recognize it, but you might encounter a bug no one has seen yet).
Functionality Limitations: Cyber provides the basics, but it won’t come with the vast standard library that Python has. If you needed to do something like parse JSON or handle complex data formats in the script, you or the operator would have to implement more in Cyber, or have the implant provide those capabilities. In contrast, Python (even embedded) gives you a rich ecosystem of libraries (if you bundle them) and a very expressive language for writing post-exploitation logic. If your use-case demands heavy scripting logic (like complex data processing on target), Cyber might be limiting. However, most on-target tasks (like looping through processes, simple calculations, conditionals for decision making) can be handled with a small language just fine.
Operator Familiarity: Red team operators are typically very comfortable with Python or PowerShell. CyberLang has a syntax somewhat reminiscent of Lua/Go (with some unique quirks, like -- for comments and optional static types). There may be a learning curve for operators to write Cyber scripts, which is an operational consideration. If your team can train on it, great – but if not, you may prefer a more familiar scripting environment.
RustPython or Other Python Engine:RustPython is an implementation of Python 3 in Rust that can be embedded as a library. In theory, this lets you run Python scripts from within your Zig (or C) implant. The big appeal of Python is its familiarity and power – an operator could write complex logic using a comfortable language. However, there are significant downsides in the context of a stealth implant:
Heavy Memory and Binary Impact: As noted, embedding RustPython can bloat an implant by many megabytes. Python is a large language with many built-ins. Even stripped down, it’s likely over an order of magnitude larger than Cyber or Lua. A 15MB implant is much more likely to be noticed (in memory or if dropped on disk) than a 500KB one. Also, running the Python interpreter consumes more memory at runtime (for bytecode, objects, etc.). This contradicts our “lightweight” design goal.
Performance: Python is not known for speed. RustPython is reportedly slower than CPython in many cases (since it’s not as optimized yet). For short-lived tasks this may not matter, but any script-intensive work could slow down the implant or cause high CPU usage that might be noticed. In contrast, Cyber’s performance is closer to LuaJIT, and languages like Lua or QuickJS (a small JS engine) are also relatively fast for an embedded language.
Detection Footprint: Python’s signatures are well-known. If you embed Python, the memory patterns (like the presence of PyInterpreterState, or certain method names) could be recognized by advanced memory scanners. Moreover, if your implant uses Python scripts heavily, it might trigger Powershell’s AntiMalware Scan Interface indirectly if those scripts invoke any managed APIs – though if fully self-contained, AMSI might not hook it. There’s also the possibility of behavioral detection: Python often performs certain syscalls or reads environment variables on startup (for locales, etc.) which a custom slim VM might not. That could tip off an EDR that a Python interpreter is running inside another process.
Integration Complexity: To embed RustPython in Zig, you’d likely compile RustPython to a C-compatible library or use a C API. This adds build complexity (mixing Zig and Rust build processes) and increases your attack surface (two different language runtimes in one process). It’s doable, but every extra moving part is another thing that can break or be detected. Cyber, being Zig, could be included at compile-time more seamlessly.
Alternative Lightweight Scripting Options: Besides CyberLang and RustPython, there are other embeddable languages worth mentioning:
Lua/LuaJIT: Lua is a tried-and-true embeddable scripting language used in many software (including malware). It has a very small core (the source is ~250KB, and LuaJIT is a bit larger but offers JIT speed). Many attackers have used Lua – for example, some malware in 2024 targeted educational sectors with Lua scripts because it’s easy to embed and less expected than PowerShell. They even avoided compiled Lua bytecode and delivered obfuscated Lua source to reduce suspicion. For an implant, LuaJIT could offer excellent performance and a small footprint. However, note that using Lua might create known patterns (e.g., the string "LuaJIT" in memory, or its bytecode structures) that an EDR could flag, since Lua-based malware is on the radar. You would also need to write binding code to expose OS operations to Lua. The benefit is many red teamers know Lua and it’s well-documented.
Wren: Wren is a small, fast scripting language (with a syntax like a mix of Lua and JavaScript) designed for embedding. It’s a single library in C with no external dependencies. Wren might be an option if you want an object-oriented scripting language that’s lighter than Python. Like Cyber, it’s not widely known in malware circles, which could be a stealth advantage.
JavaScript Engines: QuickJS is a minimal embeddable JS engine by Fabrice Bellard. It can run a good subset of ES2020 JS and the engine is only a few hundred KB. If an operator is comfortable with JS, this could be a choice. QuickJS can execute scripts from memory and doesn’t need external files. However, any JS engine will be heavier than Lua or Cyber in terms of memory, and might allocate a lot (garbage-collected). Another option is Duktape (an older embeddable JS engine known for its use in some malware as well). These give you a well-known language (JS), but you might not need that full capability.
Rhai or Starlark: Rhai is a small embedded scripting language written in Rust (focused on being easy to sandbox and integrate in Rust projects). Starlark is a Python-like language used in Bazel, with a Rust implementation. These are niche, but mentionable. Since our implant is Zig-based, using these would still require FFI, so probably not ideal. But conceptually, a constrained language like Starlark (no arbitrary OS access unless provided) might be interesting for safety – though it’s more for configuration than general scripting.
Scripting and Detection Considerations: Introducing a scripting engine means more code running in-memory, which can leave traces:
Memory Forensics: If a memory dump of the implant process is taken, the presence of an embedded interpreter could be evident. For example, strings like print, function, or known error messages from that interpreter might be present. To mitigate this, an implant could encrypt or obfuscate the interpreter in memory when not in use (similar to sleep obfuscation techniques for the whole agent). Some interpreters (LuaJIT, etc.) also produce JIT-compiled native code that resides in memory (with RWX permissions). This could trigger heuristic alarms since normally only just-in-time compilers (Edge, .NET, etc.) do that. CyberLang’s JIT is optional – you might choose to run it in interpreter-only mode to avoid RWX pages if that’s a concern, or ensure the JIT memory is freed when not needed.
AMSI and Script Block Logging: As mentioned, a custom interpreter won’t automatically invoke AMSI. However, if your script engine calls high-level functions (like spawning PowerShell or using CLR), those subsystems will invoke AMSI unless you disable it. For instance, if a Cyber script calls an implant function to execute PowerShell code via powershell.exe, Windows will scan that PowerShell invocation. But if the script confines itself to the implant’s provided primitives (like reading files, running cmd.exe commands, etc.), you sidestep those sensors. Also, PowerShell has script block logging (which logs scripts that run) – but again, if you’re not using PowerShell itself and instead doing all logic in your custom engine, you avoid that.
Execution OpSec: Running an in-memory script interpreter can be more stealthy than executing a series of native payloads. It doesn’t require new processes (the logic runs within the implant’s process), and from an EDR’s perspective, the implant process might just look like it’s performing normal API calls (file reads, network, etc.) albeit driven by unseen logic internally. However, one must be careful with output and errors – if the script prints errors or logs to console and there’s a console attached, it could be visible. Typically, a C2 implant would capture any output and send it back over C2, not actually printing to any real console.
Recommendation: CyberLang appears to be a promising choice for a lightweight, in-memory scripting engine due to its small size, speed, and memory-safe design. It aligns with the Zig philosophy and would keep the entire implant in Zig code. If an operator is willing to learn Cyber’s syntax, it can cover most needs. That said, it’s wise to provide a limited set of high-level commands as well for common tasks (like a built-in shell command to run a system command, or download to fetch a file) so that in many cases the operator doesn’t even need to drop into scripting unless absolutely necessary. This minimizes use of the interpreter (reducing exposure).If the team strongly prefers Python, an alternative approach could be running an external Python (like deploying a portable Python interpreter as described by some researchers). For instance, one could reflectively load a Python DLL or use the official embedded Python zip to run scripts. This has been done in attacks to leverage Python’s “known-good” signed binaries for execution. However, this approach is heavier on disk and potentially noisy (launching a python process). In contrast, embedding something like CyberLang keeps everything in-memory and under your control, aligning with stealthy “fileless” operation.In conclusion, embedding a scripting engine provides flexibility at the cost of additional complexity. CyberLang offers a stealthy middle-ground by keeping that complexity minimal. It allows in-memory execution of custom procedures (think of writing a quick loop in script to enumerate all users and run a command for each – you can send that as one task, rather than hundreds of individual tasks). By choosing a lightweight engine like Cyber, you retain a small implant footprint and avoid known detections on standard script engines, thus maintaining a high level of stealth.
3. Core Implant Design and Stealth Mechanisms (Inspired by Havoc)
Designing the core of the implant involves how it loads and executes malicious payloads, how it hides its presence, and how it remains flexible and stable for long-term operations. The Havoc Demon agent (written in C/ASM) provides a lot of inspiration here. It implements many modern techniques that we can adapt and potentially improve upon in Zig. Here we’ll cover process injection and in-memory execution techniques, followed by evasion tactics like API unhooking, direct syscalls, AMSI/ETW bypass, and then discuss modular architecture for maintainability.
Process Injection & In-Memory Execution
Goal: Run payloads (shellcode, DLLs, etc.) in memory without touching disk, ideally within the context of legitimate processes to blend in. A long-term implant should have the capability to migrate or inject into other processes for persistence or to perform high-privilege actions in the appropriate context.Techniques for Injection: There are numerous process injection methods, each with its OPSEC profile. We can implement several in a modular way:
Classic Remote Thread Injection: Allocate memory in a remote process (e.g., via VirtualAllocEx), write shellcode or a DLL path, then create a remote thread (CreateRemoteThread) to execute it. This is straightforward and supported by Havoc Demon (it has shellcode injection capabilities). However, it’s well-known and APIs like CreateRemoteThread are often monitored by EDR. If we use this, we’d want to obscure those calls (e.g., using direct syscalls instead of the Windows API, see below). Zig can call these APIs directly or use syscalls for stealth.
Early-Bird and APC Injection: These involve injecting code into a thread before it executes or via Asynchronous Procedure Calls. For example, create a suspended process of a benign executable (CreateProcess with CREATE_SUSPENDED), map malicious code into it, then resume it (Early-Bird) or queue an APC to the thread that triggers our code when it resumes. Havoc’s Demon or its loader uses similar ideas (Havoc’s default loader is a shellcode that decrypts Demon and uses NtQueueApcThread in some cases). Implementing this in Zig is feasible: after creating a suspended process, use NtMapViewOfSection or write process memory, then adjust the thread context to point to our code (SetThreadContext) before resuming. These techniques are stealthier as they avoid obvious functions; they often don’t create new threads (they hijack existing ones).
Thread Hijacking: As demonstrated in Zig Strike toolkit, you can hijack an existing thread in a remote process by pausing it, changing its instruction pointer to your shellcode, and resuming. This avoids creating any new threads. The Zig Strike “Remote thread hijacking” technique uses GetThreadContext/SetThreadContext to redirect a thread to the malicious code. An advantage is that no new thread start event occurs (which some EDRs hook), though suspending a thread in another process is still a detectable action. Our Zig implant could incorporate this by having a module for “Run shellcode in Process X via thread hijack.” It requires finding a suitable thread (one that is in a wait/sleep state) and safely injecting.
Process Hollowing: Also known as RunPE, this involves creating a process in suspended state (usually a benign host like svchost.exe), then unmapping its executable sections and replacing them with the payload (either a PE or shellcode), then resuming. It “hollows out” the original process and puts our code in its place under the original process name. Havoc’s Demon could be delivered this way by some loaders (though Havoc itself might not implement hollowing directly in Demon). For us, implementing hollowing in Zig would involve low-level PE parsing and writing to memory – doable given Zig’s ability to handle binary data easily. We must also fix up the thread context to point to the new entry point.
Module Stomping / Reflective DLL Injection: This is loading a DLL’s content into memory without using Windows loader. Havoc Demon can load .NET assemblies in-memory and also reflectively load its Demon DLL in a remote process using shellcode (Zscaler noted Havoc’s loader uses a shellcode “KaynLdr” that reflectively loads the Demon DLL without headers)​
ZSCALER.COM
. We should similarly allow our implant to load new modules (DLLs or EXEs) without touching disk. One approach is to allocate memory for the PE, manually perform relocations and import resolution, then start a thread at its entry (the classic reflective load). Alternatively, use “memory module” technique: allocate as if it were a section mapping. Zig could make this easier with its ability to handle pointers and call C functions – we could even integrate an existing C reflective loader library. Removing DOS/NT headers after loading is important to avoid memory scanners detecting the signature of a loaded PE​
ZSCALER.COM
. Our implant should scrub or encrypt those headers once the module is loaded.
File Mapping Abuse: A newer stealth technique is to use file mapping APIs to create memory that looks like mapped files rather than typical VirtualAlloc regions. Zig Strike’s “Local Mapping” uses CreateFileMappingW on the pagefile and MapViewOfFile to allocate memory for shellcode, which results in a region that appears as a mapped file (which some EDRs might treat as less suspicious). Similarly, “Remote mapping” uses MapViewOfFileNuma2 to map memory into another process. These techniques avoid calling VirtualAllocEx directly for injection. We can incorporate this by using Windows native APIs or syscalls for section mapping. It’s a trade-off: complexity vs. stealth. But since we aim for stealth-focused, it’s worth implementing at least one such advanced method.
In-Memory Execution: Beyond injection, the implant itself might execute additional code in-memory for tasks:
Running .NET assemblies in-memory (like Havoc’s inline-execute for .NET). This involves loading the CLR COM object, disabling AMSI (Havoc patches amsi.dll after initializing CLR), and hosting a .NET assembly without ever writing it to disk. We can consider a simplified version: if a task comes with a .NET assembly, our implant (if running on a system with .NET) could load clr.dll and use hosting APIs to run it. This is heavy for a lightweight implant, so unless .NET tradecraft is needed, we might skip it. However, it’s an example of how an implant can extend capabilities at runtime.
Executing PowerShell in-memory: Instead of spawning powershell.exe (which is highly monitored), one can use a runspace via PowerShell’s .NET SDK or use System.Management.Automation inside a .NET host. This again might be beyond our Zig implant’s native scope (though one could embed something like PowerShell’s DLL). Most likely, we’d just spawn powershell with proper arguments and AMSI patched if needed, or avoid PowerShell altogether in favor of direct API usage via our own code.
Stealth and OPSEC for Injection: No matter the method, several best practices apply:
After injection or loading code, scrub evidence. Overwrite or free any memory buffers in the source process that held plain-text shellcode or DLL contents (so memory scanners don’t find those easily).
Use 64-bit implants on 64-bit systems to avoid WOW64 which can complicate or raise suspicion (also WOW64 syscalls behave differently).
Ideally, migrate out of the initial process (like a Microsoft Word macro spawns the Zig implant, which then injects into a more benign host and terminates the original). This reduces chances of blue teams noticing an unusual process running. Choose host processes that make sense for long-term dwell (e.g., explorer.exe for user-level, or a service process if needing SYSTEM access). Havoc Demon, for instance, might often run under a hollowed svchost.exe in real attacks​
ZSCALER.COM
.
Implement a sleep (beacon) loop where the implant does nothing most of the time and only wakes periodically. While sleeping, some implants encrypt or guard their memory (“sleep obfuscation”). Havoc uses techniques like Ekko or FOLIAGE to obfuscate memory during sleep. We should consider this: e.g., XOR encrypt sections of our implant’s memory (especially any readable strings or code) while idle, and decrypt briefly when tasks arrive. This can confuse memory scans that happen at random intervals. Zig can make this efficient, especially with comptime to embed a key or using low-level memory access to loop over pages. Sleep obfuscation helped Havoc bypass Windows Defender​
ZSCALER.COM
, and is increasingly a standard feature in modern C2 agents.
Evasion Techniques: API Unhooking, Direct Syscalls, AMSI & ETW Bypass
Modern EDRs heavily instrument and monitor processes to catch malicious behavior. Our implant must therefore neutralize or avoid these monitoring techniques:
API Unhooking: Many EDRs inject DLLs and patch (hook) critical API functions in user-mode (especially in ntdll.dll and kernel32.dll). For example, functions like VirtualAlloc, NtProtectVirtualMemory, CreateProcessW, etc., may be hooked to record or block malicious usage. One way to evade is to “unhook” these functions by restoring the original bytes. Our implant can detect hooks by comparing the in-memory bytes of ntdll.dll functions to a clean copy. A classic approach: load a fresh copy of ntdll.dll from disk into memory (using a trick like LoadLibraryEx with an alternate path) and then copy the first several bytes of each function from the clean copy over the possibly hooked ones in the main module. This effectively removes the EDR’s trampoline hooks. This is something Outflank’s OST tool does automatically (“hooks clean” to unhook all userland hooks)​
OUTFLANK.NL
. We can implement a similar feature. Zig makes it easy to manipulate raw bytes in memory, but care is needed (changing code on the fly). Alternatively, preventing hooks in the first place: if you call lower-level functions or syscalls directly, EDR hooks might never get a chance (since they usually hook the API, not the syscall instruction itself).
Direct Syscalls: Instead of calling NtWriteVirtualMemory via the normal API (which goes into ntdll and could be hooked), the implant can execute the syscall instruction directly with the correct syscall number for the current OS. Tools like SysWhispers and direct assembly do this in C/C++ implants. In Zig, you could include or generate the minimal assembly for a syscall. Havoc Demon uses indirect syscalls, meaning it calls a syscall via a return-oriented gadget or other indirection to avoid straight API usage​
ZSCALER.COM
​
ZSCALER.COM
. By doing syscalls, you bypass user-mode hooks entirely (EDR would have to hook at kernel level to catch it, which is much harder for them and less common). The trade-off: syscalls are OS-version specific (syscall numbers change between Windows versions). But there are well-known stable ones for core functions. We could implement a set of direct syscalls for critical needs (memory allocation, process creation, etc.), using Zig’s inline assembly or by embedding pre-compiled syscall stubs. This significantly improves stealth for those operations. Note that using direct syscalls can sometimes be detected by heuristic (like “hey, this thread executed a syscall from a non-ntdll region”), but it’s less straightforward to catch. Some EDRs now watch for address spoofing and unusual call stacks (since normally syscalls should originate from ntdll). A further evasion is return address spoofing – Demon does return address stack spoofing to make it look like the call came from a legitimate caller on the stack​
ZSCALER.COM
. We could mimic that by manipulating the stack around our syscall invocation (advanced but doable).
ETW Patching: ETW (Event Tracing for Windows) is used by EDRs to get telemetry from user-space without hooks (providers like Microsoft-Windows-Threat-Intelligence, aka ETW TI). A known bypass is patching EtwEventWrite to return immediately, disabling the event tracing. Many tools, including Cobalt Strike’s sleep mask and Havoc’s loader, do this. We will do the same: find the address of EtwEventWrite (and related functions like EtwEventWriteFull or NtTraceEvent) in ntdll.dll and overwrite the first bytes with a ret instruction. This effectively neuters a lot of user-mode logging. The Zscaler report noted Havoc’s shellcode loader disables ETW early on​
ZSCALER.COM
 – we should do it as soon as our implant starts, before doing any high-profile actions. Patching NtTraceEvent at the syscall level (in ntdll) is the most thorough approach. This is a small patch (just writing 0xC3 byte in memory for x64 ret) but yields significant stealth benefit. Very few things should legitimately patch ETW, so one must hope the EDR doesn’t catch the act of patching itself – but currently, many open-source tools do this without issue.
AMSI Bypass: If our implant ever invokes any script interpreters or calls things that go through AMSI (like PowerShell, or even loading a .NET assembly might trigger an AMSI scan of the assembly bytes), we need to bypass AMSI. The typical method is similarly patching the functions AmsiScanBuffer (and AmsiScanString) in memory to return a clean result always. This again is done by writing a ret 0 (or setting the result register to AMSI_RESULT_CLEAN then ret). Havoc Demon, when doing inline-execute of .NET, specifically loads amsi.dll and patches it in-memory before executing the assembly. We will integrate an AMSI patch that activates whenever the implant starts or before any high-level script execution. Zig can locate the AMSI DLL in-memory if loaded (or force-load it via LoadLibrary and then patch). A small caveat: if AMSI isn’t loaded yet, you can also stub the import – but in our case, easier to just load and patch at runtime. This will defeat Windows Defender’s dynamic script content scanning, which is crucial if using any higher-level language or even some LOLBins.
EVADING Hooks with Alternative Functions: Sometimes you can avoid triggering hooks by using less common API or syscalls. For example, instead of CreateRemoteThread, an implant might call NtCreateThreadEx (which might not be hooked in older EDRs, or at least was less commonly). Or instead of WriteProcessMemory, use NtMapViewOfSection to write memory. The implant design should favor these lesser-known pathways. Another trick: some EDR hooks can be bypassed by calling the same API but via a function pointer from a known unhooked module. However, that’s situational. Given we can do direct syscalls, that is the more robust solution.
Avoiding Suspicious APIs Altogether: Design your implant to not use certain APIs if possible. For example, OpenProcess with full access is noisy – if you spawn a process yourself, you already have a handle. Or use duplication of handles from child processes to get handles without calling OpenProcess. Another example: avoid TerminateProcess for stealth; schedule a graceful exit in the target if you need to kill it. These are micro-optimizations beyond Havoc’s scope, but thinking this way further reduces detection.
Stealthy Module/Function Resolution: Rather than calling APIs by name (which might leave those name strings in your binary or attract attention if resolved normally), use dynamic resolution techniques:
Use hashing of function names (Havoc Demon uses a modified DJB2 hash to look up API addresses in memory)​
ZSCALER.COM
. Our Zig implant can compute hashes of needed API names and only resolve them by walking the export tables at runtime. This way, the cleartext API names (like "VirtualAllocEx") don’t appear in the binary for static scanners to pick up. It’s a tried-and-true malware trick.
Alternatively, leverage Zig’s ability at compile-time: we could XOR-encrypt strings and decrypt in memory, or hide them in an obscure data section.
Modular Architecture Considerations:For long-term maintainability and flexibility, structuring the implant in a modular way is wise. This doesn’t mean it has to support runtime plugin loading (which is complex and risky), but the code organization and functionality should be modular:
Separation of Concerns: Divide the implant’s functionality into components: e.g., Networking/C2 module, Injection module, Evasion module, Command Handler, Scripting Engine, etc. In Zig, this could simply be different files or even compile-time optional features. The idea is you can update or improve one part (say, swap out the C2 channel or add a new injection technique) without rewriting everything. This also helps with debugging – you can test modules in isolation (for instance, test the injection module on its own in a benign way).
Command Dispatcher and Handler Registration: Design an internal structure where each supported command (like "shell", "upload", "execute-assembly", etc.) is defined in one place with its handling logic. This is similar to how Havoc or Cobalt Strike have a set of built-in commands. For example, Havoc’s Python API defines commands with a CommandId and handling code. We can do it in Zig natively. Possibly use an enum or hash map of command names to functions. This makes it easy to add new commands in the future or disable certain commands by policy (if an op wants a minimal footprint operation, they might strip out heavy features).
Modularity for Evasion: We might not always want all evasion techniques active (some might break compatibility or cause instability on certain systems). So if we structure things like “AMSIPatch()”, “ETWPatch()”, “UnhookAll()” as separate functions, an operator could choose which to invoke (perhaps based on implant configuration or commands from C2). For instance, only patch AMSI right before running a script, not 100% of the time, to reduce chances of conflict. Or allow toggling sleep obfuscation on/off. A modular approach allows this flexibility.
Future Upgrades: A long-term implant should consider how to receive updates. One approach is to build a stager that can fetch and load an updated core (like how Cobalt Strike can stage a new Beacon). With Zig, we could implement a simple updater: the implant could download an encrypted new DLL or shellcode and use one of the in-memory execution techniques to run it (effectively replacing itself or launching the new version). Planning for this means keeping the core lightweight and having a mechanism to transfer state (e.g., the new agent should know the old agent’s configuration like implant ID, etc.). Havoc supports external agents, but for our custom one, we’d handle it ourselves. Alternatively, ensure the implant is robust enough that it doesn’t require frequent updates mid-operation.
Minimal Exposure of Modules: Only load or initialize heavy modules when needed. For example, if the scripting engine or a secondary payload is not used until later, perhaps don’t allocate it until commanded. This way, any unusual memory patterns (like a large interpreter) aren’t present on the system until absolutely necessary. It’s a trade-off with detection: loading it late could itself trigger an alert, but depends on context.
Logging and Error Handling: A maintainable implant should have some way to report errors or status (likely back to C2). If a particular technique fails (e.g., injection failed), the agent could try a fallback method or at least notify the operator. This kind of resilience is important for long-term ops so that the operator isn’t blind to what’s going wrong. For stealth, obviously no logging goes to disk or standard output – all internal errors should be either suppressed or sent covertly to C2.
Ethical and Safety Considerations: We design with the assumption this implant is used ethically in red team engagements. Still, one must incorporate safeguards: for instance, limit potentially destructive actions (you might not include a “delete file” command unless needed, to avoid accidents). Also implement proper cleanup – if the implant is commanded to uninstall, it should attempt to remove any lasting artifacts (like scheduled tasks or registry keys it may have added for persistence). Ensuring the implant doesn’t destabilize the system is also key (test injection techniques thoroughly to avoid crashing target processes). A bug in an implant can have real-world consequences in a production environment, so extensive testing of each module is part of maintainability and ethics.
In summary, the implant’s core should be stealthy by design. By using sophisticated in-memory execution techniques and layering on evasion (unhooking, syscalls, patching sensors), we reduce the chances of detection dramatically. Havoc’s Demon already proved that with indirect syscalls and sleep obfuscation it could bypass even Windows 11 Defender​
ZSCALER.COM
. We take inspiration and go further by leveraging Zig’s low-level capabilities to implement those tricks in a streamlined way. At the same time, a clean modular design ensures we can adapt to new defenses (e.g., if a new Windows version changes syscall numbers or if a new sensor appears, we can update that module without reworking everything). This modular stealth approach gives our adversary simulation implant the best chance to remain undetected over long durations on target networks.
4. C2 Communication Considerations (HTTP C2, Cloudflare for OPSEC, Alternative Channels)
Communication between the implant and the command-and-control (C2) server is the lifeline of an operation. It must be covert, flexible, and resilient. Havoc uses an HTTP/HTTPS-based C2 with customizable profiles, and we aim to design a similar or improved channel.HTTP/HTTPS C2 with Improved OPSEC: HTTP(S) is popular for C2 for good reason – web traffic is ubiquitous and blends in. We will use HTTPS to encrypt transport and appear as normal TLS web traffic. However, just using HTTPS is not enough; one must consider how to blend in:
Malleable C2 Profile: Design the implant’s HTTP requests to mimic legitimate traffic patterns. This includes the URI paths, headers, request frequency, and packet size. Havoc allows customizing these (like URIs and headers to impersonate common web services). We should do similarly. For example, have the implant’s beacon GET request look like an innocuous GET to a known endpoint (e.g., /api/v1/sync or /images/logo.png). Use Host headers that point to a legitimate-looking domain. Perhaps the implant can fetch instructions via a URL that looks like a CDN or cloud service request.
Domain Fronting and CDN Proxying: One powerful OPSEC improvement is leveraging content delivery networks (CDNs) like Cloudflare, Cloudfront, or Azure Front Door to mask the true C2. Domain fronting traditionally meant using one hostname in the TLS SNI and another in the HTTP Host header to trick CDNs. Cloudflare has closed the classic fronting, but you can still use Cloudflare’s infrastructure by hosting your C2 behind it or using Cloudflare Workers. For instance, you could register a domain with Cloudflare and have all C2 traffic go through Cloudflare’s servers, which then reverse-proxy to your teamserver. To an observer, the implant is just talking to Cloudflare IP addresses (which are very common) and the TLS certificate will be for your domain (which could be a subdomain of a Cloudflare-served site). This makes IP-based blocking or identification very hard – as one researcher noted about malware using Cloudflare Workers: the C2 appears as a Cloudflare IP, making it impractical to block without blocking all of Cloudflare​
BLEEPINGCOMPUTER.COM
. In our design, using Cloudflare or a similar CDN means even if an organization detects “something fishy” with the traffic, they can’t easily differentiate it from normal traffic to Cloudflare without deeper inspection.
Cloudflare Workers / Serverless Edge: We could even implement part of the C2 logic in a Cloudflare Worker (a JavaScript snippet running at the edge). For example, the implant might send an HTTP POST to a Cloudflare Worker URL (e.g., <random>.workers.dev) with an encrypted blob. The Worker can decrypt (if it has the key) or simply forward it to the actual C2 server. This is what the BlackWater malware did: it used a Cloudflare Worker as a “C2 interface” to forward requests to the real backend​
BLEEPINGCOMPUTER.COM
​
BLEEPINGCOMPUTER.COM
. The Worker can add another layer of filtering (maybe checking a cookie or auth token in requests). Using such infrastructure can significantly improve stealth: traffic to Workers is still just seen as Cloudflare. Additionally, these services often use domain fronting-like behavior internally, e.g., the TLS connection is to Cloudflare and the host header routes to your Worker. The key is that on the wire, an IDS sees only a request to a Cloudflare domain.
Frequency and Size Management: The implant should communicate at intervals that don’t arouse suspicion. Havoc’s sleep/jitter can be imitated (e.g., beacon every 60 seconds with a 20% jitter, meaning ±12s randomization). Long-term implants often spend most of their time sleeping to reduce network noise. When they do beacon, the amount of data should be small (a few hundred bytes) unless exfiltrating. We also ensure to use HTTP protocol correctly: maybe sometimes include benign-looking referrers or cookies to appear more legitimate. Also consider using flow padding – e.g., if sending very small packets might be odd, pad responses to a minimum size or random size to mimic images or typical API responses.
Fallback to HTTP if necessary: If HTTPS egress is entirely blocked (rare, but some secure envs inspect SSL), the implant could potentially downgrade to HTTP or another channel. However, plaintext HTTP is risky as it can be observed and easily content-filtered. A compromise is to implement an internal domain fronting: for instance, the implant makes an HTTPS request to a major domain (like https://www.microsoft.com with Host header of your C2 domain). Some older CDNs allowed that (this is classic domain fronting). If you find a frontable domain with a CDN that still allows it, that could be a trick in the toolkit.
Leveraging Cloud Infrastructure for Stealth: Beyond CDNs, consider using cloud storage or APIs:
Using Amazon S3 or Azure Blob URLs for C2 (the implant PUTs data to a storage container and the operator reads it). This has high stealth (looks like normal cloud storage access) but adds latency and complexity.
Using Google Docs/Sheets or other well-known web services as dead-drops (the implant posts content that looks like normal user traffic).
Each of these has trade-offs in reliability and speed, so a flexible design might allow switching C2 profiles.
Alternate Channels (DNS, WebSockets, etc.):
DNS Tunneling C2: DNS queries are often allowed out even when HTTP is heavily restricted. The implant could implement a DNS-based C2 as a backup. This means encoding data in DNS query hostnames (e.g., <data>.<companydomain>.com) and having a DNS server that responds with encoded answers. This is very slow and low-bandwidth, but extremely stealthy under the right conditions (it blends with normal DNS, though large volumes of queries or odd-looking domains can get noticed). We might include a minimal DNS client to use the system resolver for this. If using DNS, we’d likely limit it to short messages (like beacon presence and ask for “go/no-go” or small tasks). This could be an emergency channel if HTTP is cut off.
WebSockets: A WebSocket is essentially an upgraded HTTP connection that stays open and can send bidirectional data. Implementing a WebSocket client in Zig is feasible (basically an HTTP handshake then frames). WebSockets over port 443 could look like normal WebSocket traffic used by many web apps. Using WebSockets might allow low-latency, continuous communication (which is a double-edged sword: more active traffic might be noticed on network). But it could be useful for certain interactive tasks (like a pseudo-shell). We’d likely only initiate a WebSocket when needed (like when operator opens an interactive session). Otherwise, we stick to beaconing.
Covert Channels: There are many creative channels – like hiding data in ICMP echo request/reply (ping packets), or using SMB named pipes (for lateral movement within a network), or abusing legitimate protocols (SMTP, IMAP, etc.). For internet C2, one interesting vector is SMTP/Email – an implant could send an email (via SMTPS) to a mailbox controlled by the team (exfil data) and read commands from incoming emails. This is slow and complex, but sometimes is allowed out when everything else is blocked. Another covert trick: use image steganography on web requests – e.g., implant downloads what appears to be a GIF from your server, but actually the pixel data encodes encrypted commands. To a blue team, it’s just an image.
In practice, implementing multiple channels means more code, which might bloat the implant. A common approach is to build a primary channel (HTTPS) and a secondary for backup (DNS or SMB for internal pivoting). We can configure the implant with which to use.OPSEC for C2 Servers: On the server side, make sure to isolate and secure your C2 infrastructure:
Use domains that blend in (no obvious names like “maliciousC2.com”).
Rotate or have per-operation infrastructure so if one op is burned, others aren’t. The implant could be configured to talk to multiple domains (for redundancy).
Leverage cloud instances or CDN to reduce the chance that sinkholing or IP blocking will catch you mid-engagement.
Also ensure C2 communications are encrypted at application level in addition to TLS. That way, if TLS is terminated (e.g., by a corporate proxy that does SSL inspection), the content is still encrypted (maybe via AES in the payload). Havoc likely already encrypts taskings inside HTTPS; we should do the same (this also prevents simple string detection if traffic gets logged).
Handling C2 Interactions: The implant should properly implement checks and authentication:
Use an authentication scheme (Havoc uses an API token in a header, Mythic uses AES with session keys, etc.). For our Zig implant, we can derive an encryption key per session from a pre-shared master key (embedded in the binary or obtained during staging). All C2 messages could be AES-GCM encrypted with that key, and maybe include a sequence number or nonce to prevent replay.
The implant must verify server identity too (e.g., pin the TLS certificate or expect a certain domain). This prevents accidental connecting to a wrong host or sinkhole. It’s an often overlooked OPSEC point – if an implant is pointed at domainfront.cloud.com, and the blue team somehow takes over that DNS or intercepts, they could feed fake tasks. Having an application-layer crypto with authentication mitigates this (the server needs the right key to issue tasks that the implant will accept).
Resilience: If no C2 is available (server down or network cut), the implant should not crash or consume high resources trying. Implement back-off strategies (e.g., if can’t reach server for X tries, lengthen beacon interval). Possibly implement a secondary C2 server as backup in config. Also, be cautious of what the implant does upon failing to reach C2 – ideally just sleep and retry, rather than exiting (so that if network comes back, it resumes).All these communication considerations ensure that once our stealthy implant is running, it can actually be controlled and used without giving itself away. We improve on Havoc by integrating cloud CDN fronting and possibly alternative channels, which makes our C2 traffic blend into the fabric of normal network traffic. For a modern red team, this is crucial, as network detection analytics are very strong. As one source points out, domain fronting and CDN abuse can make C2 “one of the hardest techniques for enterprise security teams to detect” – exactly what we want.
5. Custom Zig Implant vs. Modifying Havoc or Developing a Mythic Agent
Given the significant effort described, it’s important to evaluate whether building a custom Zig implant from scratch is worthwhile, versus leveraging existing frameworks like Havoc or Mythic. Each approach has pros and cons, and the decision may come down to your specific goals and resources.Time Investment vs Benefits (Custom Zig Implant): Writing a full-featured implant is non-trivial – we must implement networking, encryption, task parsing, a range of functionalities (file ops, process ops, etc.), and test evasion techniques against security products. This is certainly a larger time investment than simply using or slightly modifying an existing agent. However, the benefits of a fully custom Zig implant are:
Unique Tool, Unique TTPs: A custom implant is your bespoke tool. It’s not publicly known, so there are no threat intelligence signatures for it. Havoc’s Demon, while new, is open source and already seen in the wild (e.g., Zscaler observed it in campaigns​
ZSCALER.COM
​
ZSCALER.COM
). EDR vendors have likely studied Havoc’s behavior by now. By building your own, you present defenders with something they haven’t seen before, forcing them to rely on behavioral detection rather than easy intel. You can also integrate novel techniques that aren’t in Havoc by default (like the Cloudflare C2 or certain injection tricks), raising the bar for detection.
Granular Control: A custom implant lets you choose exactly which features to include, minimizing bloat. Havoc’s Demon is fairly lean compared to say, Cobalt Strike’s Beacon, but it still has some features or code paths you might not need. Each feature is a potential attack surface for detection or malfunction. With your own project, you can say “We don’t need X, so it won’t exist in the binary at all.” This reduces the number of IOCs. You can also tailor it to your target environment (e.g., if you know you only need Windows 10 x64, you can optimize for that and drop any legacy compat code).
Learning and Skill Growth: From an ethical red team perspective, building your own implant significantly enhances your skillset and understanding of post-exploitation. This can be a benefit to the team in the long run – you’re not treating the implant as a black box; you know exactly how it works. This means you can adjust on the fly during an engagement if needed (because you know the internals). While this isn’t a direct benefit to the operation’s success, it contributes to the team’s capabilities.
However, time is money – and developing such a tool can take weeks or months of coding and testing. If your operation is soon or resources are limited, modifying an existing project might be more practical.Using or Modifying Havoc:Havoc Framework is open source and already implements much of what we discussed (in C). One could take Havoc’s Demon agent and modify it (e.g., add Zig-based components or adjust its behavior). Some points here:
Havoc is in C/ASM, so adding complex new features might be as much work as doing it in Zig. However, simple modifications (like changing its network indicators, or integrating a different loader) could be done relatively quickly. Havoc was designed to be malleable: it has malleable C2 profiles and an extension system​
GITHUB.COM
. If Havoc “falls short” in an area, you might extend it. For example, if you want a scripting engine in Havoc, you might write a module in C that interfaces with Lua or Cyber (though mixing Zig into it might be complicated, you could compile Zig to object file and link it in perhaps).
Detection of Havoc: Since Havoc is newer than Cobalt Strike, it’s less known, but it’s gaining attention from defenders (as of 2023/2024). Zscaler and others have published research on detecting Havoc​
ZSCALER.COM
​
ZSCALER.COM
. If you use Havoc out-of-the-box, and the target environment has those threat intel indicators loaded, you could get caught. Minor modifications (like changing hash values or sleep obfuscation patterns) could help, but once an EDR knows the general behavior (like Havoc’s default process injection sequence, or its packet structure), it could still catch it. A Zig implant can diverge more fundamentally from Havoc’s known patterns (e.g., different encryption, different timings).
Rapid Development: The advantage of starting from Havoc is that a lot of groundwork (teamserver, UI, etc.) is done. You could focus just on improving the agent. In fact, Havoc’s teamserver supports custom third-party agents via a service API. You might not have to modify Demon at all; you could write a Zig agent that communicates with Havoc’s server as an “ExternalC2” agent. This is a hybrid approach: build your Zig implant but have it use Havoc’s C2 protocol so you can use the Havoc UI. Havoc provides a Python API to register a new agent type. If you reverse-engineer or use that, you can save building a whole C2 infrastructure. The downside is you are then tied to Havoc’s protocol (which an EDR might recognize since it’s public). But you could tweak the protocol as well.
Developing a Mythic Agent:Mythic is a well-established open source C2 platform that uses a different architecture (Mythic server with Dockerized “translation” containers and a web UI). It supports multiple agents (Apollo, Poseidon, etc.) in various languages. Writing a Mythic agent in Zig is possible, but consider:
Mythic Complexity: Mythic is heavy. It leverages containers, RabbitMQ, database, etc. – a lot of moving parts. Creating a new agent means adhering to Mythic’s payload type schema, and possibly writing a translator container if the agent can’t natively handle JSON (Mythic passes tasks as JSON by default)​
RED-TEAM-SNCF.GITHUB.IO
​
RED-TEAM-SNCF.GITHUB.IO
. Zig could handle JSON, or one could write a small C translator. The Red Team SNCF blog mentioned Mythic’s steep learning curve and complex docs for this reason​
RED-TEAM-SNCF.GITHUB.IO
. So, developing a Mythic agent has a learning overhead itself (the framework, not just the agent code).
Benefits of Mythic Agent: If you succeed, you instantly get Mythic’s entire ecosystem: a user-friendly UI, a slew of implemented commands you can mimic, and existing C2 profiles (Mythic also supports C2 over HTTP/DNS, etc., which you could reuse rather than writing your own server). This is a big time saver. Also, Mythic is actively maintained – as new techniques come, Mythic’s community might integrate them, and you could update your agent to use them.
OPSEC of Mythic: Mythic being open source means defenders also know how its agents communicate and operate. A custom agent can diverge, but if you conform to Mythic’s defaults (like the JSON format, or the way it handles chunking), there’s a risk those patterns are known. If stealth is the absolute priority, relying on a known framework can be a weakness. However, Mythic is modular enough that you can customize a lot (for example, use a custom C2 profile with different encryption or packaging of tasks). It also encourages custom malleable profiles.
Speed of Development: You could likely get a basic Zig agent working with Mythic faster than building a complete custom C2 from scratch. The Mythic documentation and examples (like the C agent or others) provide a template​
RED-TEAM-SNCF.GITHUB.IO
. You’d implement a check-in, tasking loop, and a handful of functions to parse tasks and execute them. This could be a matter of days to get a minimal beacon running. In contrast, a custom project could be weeks for the same. If time is short, writing a Mythic agent might be the pragmatic choice. You can still incorporate Zig advantages (small binary, custom evasion in how it does things) inside that agent.
Why Not Just Use Cobalt Strike or Another Commercial Tool? – This question wasn’t explicitly asked, but it’s worth noting: many red teams use paid tools (CS, Brute Ratel, etc.) for convenience. The reason one might avoid those in this context is OPSEC: those tools are extremely well-known to defenders and can be caught despite their evasion, especially by mature organizations. Our focus here is on bespoke lightweight stealth, which is why we are debating between open-source frameworks vs building our own.Where Havoc Falls Short (and Zig Implant Could Improve):
Havoc is still in early release; it might have bugs or missing features (for instance, as of early releases, it didn’t have a full P2P or some advanced exfil capabilities). By writing our own, we tailor features to exactly what’s needed.
Havoc’s demon is C-based; it means dealing with pointers and potential memory issues without the slight safeguards Zig provides. A Zig implant could be more stable if written carefully, and easier to extend (no dealing with C string quirks, etc.).
Havoc has a dependency on its teamserver and UI. If those components fail or are detected, your agent goes down too. A custom solution could be simpler and maybe easier to couple/decouple as needed. That said, the Havoc teamserver is a strength too (multi-user, etc.), but you might not need that in a small engagement.
Why consider Mythic agent or not:
Consider if you already have Mythic deployed in your environment or skillset. If yes, adding a Zig agent is like adding another tool in the Mythic toolbox. If not, spinning up Mythic might be overkill if you only need one custom agent.
Also note Mythic agents tend to be a bit larger because they include some standard library for JSON and crypto. But a Zig agent could be optimized to be small and still work with Mythic if done carefully (maybe offload JSON parsing to translator container to keep agent small).
Ethical & Operational Notes: No matter which route, ensure you operate within authorization. Custom implants should have a way to positively identify they’re under control (so they don’t get re-used by actual bad actors if found). Mythic and Havoc have teamserver authentication, etc.; a custom implant should similarly refuse connections not signed by your C2 keys.Finally, maintaining a custom tool requires commitment. Threat defenses evolve, so your implant might need updates when a new Windows 11 patch, for example, introduces a new security measure (maybe breaking your syscall numbers or blocking an API pattern). With a community tool, you benefit from community updates. With your own, you need to stay on top of it. If you have that dedication, a Zig implant can be a powerful long-term asset for your red team, giving you an edge in stealth.Conclusion & Best Practices: If ultimate stealth and control are required, investing in a custom Zig implant makes sense – it can incorporate cutting-edge evasion, and you fully own the TTPs. Use Havoc or Mythic code as references or even piggy-back on their server components if that accelerates development, but avoid using any default behaviors that defenders might know. Make sure to thoroughly test your implant in a lab with various EDR solutions (Defender, CrowdStrike, etc.) turned on. Watch for any detections or abnormal crashes and refine accordingly. Adopt a mindset of “assume my tool will be analyzed” – build in layers of encryption, obfuscation, and fail-safes so if it’s discovered, it yields minimal intel (e.g., wipe config from memory on exit, etc.). By following these practices, you can ethically operate a sophisticated Zig-based adversary simulation implant that remains stealthy in modern Windows environments, while also maintaining the flexibility to adapt as needed.Sources:
OffensiveZig Project – Why Zig for implants (cross-compiling, no runtime, small binaries)
Zig vs Rust and C discussion – Zig’s simplicity and safety features vs Rust’s complexity
CyberLang (Cyber) Scripting – embeddable Zig scripting language (memory safe, fast, concurrent)​
STS10.GITHUB.IO
RustPython embedding example – binary size overhead (~15 MB vs 400 KB)
Morphisec Lua Malware analysis – attackers using Lua scripts for stealth, avoiding bytecode due to detection
Havoc Demon & Evasion – uses indirect syscalls and sleep obfuscation to bypass Defender​
ZSCALER.COM
; patches AMSI before executing in-memory assemblies; disables ETW events​
ZSCALER.COM
Vaadata on AMSI/ETW patching – patch AMSIScanBuffer and EtwEventWrite with ret to disable scans
Outflank (Stage1) on unhooking – strategy to detect and remove EDR hooks in userland APIs
Cloudflare Workers for C2 – using Cloudflare as a reverse proxy makes blocking very difficult​
BLEEPINGCOMPUTER.COM
; malware used Workers to hide C2​
BLEEPINGCOMPUTER.COM
Mythic Agent dev (Red Team SNCF) – Mythic’s plug-n-play design for custom agents, but with complexity of translators and containers​
RED-TEAM-SNCF.GITHUB.IO
​
RED-TEAM-SNCF.GITHUB.IO